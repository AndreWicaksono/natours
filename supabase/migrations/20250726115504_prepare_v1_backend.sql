-- #############################################################################
-- ### 1. EXTENSIONS, SCHEMAS & CUSTOM TYPES
-- #############################################################################

-- EXTENSIONS
CREATE EXTENSION IF NOT EXISTS "postgis" WITH SCHEMA "extensions" VERSION '3.3.7';

-- SCHEMAS
CREATE SCHEMA IF NOT EXISTS "account";
CREATE SCHEMA IF NOT EXISTS "billing";
CREATE SCHEMA IF NOT EXISTS "geography";
CREATE SCHEMA IF NOT EXISTS "internal_api";
CREATE SCHEMA IF NOT EXISTS "tour";

-- ------------------------------------------------------------------
-- API Permissions (internal_api)
-- ------------------------------------------------------------------
-- Allow PostgREST / GraphQL clients to reference objects inside the internal_api schema.
GRANT USAGE ON SCHEMA internal_api TO anon, authenticated, service_role;

-- Automatically give authenticated and service_role rights to read and modify any tables that will be created in internal_api going forward.
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA internal_api
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated, service_role;

-- Needed only if we intend to expose (call) functions via GraphQL/RPC.
-- GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA internal_api TO anon, authenticated, service_role;

-- Needed only if we explicitly want clients (or PostgREST/GraphQL) to query the current/next value of those sequences with currval() / nextval() calls.
-- GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA internal_api TO anon, authenticated, service_role;

-- Needed only if we intend to expose (call) functions via GraphQL/RPC.
-- ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA internal_api
-- GRANT EXECUTE ON FUNCTIONS TO anon, authenticated, service_role;

-- Needed only if we explicitly want clients (or PostgREST/GraphQL) to query the current/next value of those sequences with currval() / nextval() calls.
-- ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA internal_api
-- GRANT USAGE, SELECT ON SEQUENCES TO anon, authenticated, service_role;


-- CUSTOM TYPES (ENUMS)
CREATE TYPE "public"."app_role" AS ENUM ('customer', 'guide', 'lead_guide', 'admin', 'partner_admin');
CREATE TYPE "public"."booking_status" AS ENUM ('pending', 'confirmed', 'cancelled', 'expired');
CREATE TYPE "public"."location_level" AS ENUM ('country', 'province', 'city', 'district', 'sub_district', 'point_of_interest');
CREATE TYPE "public"."payment_status" AS ENUM ('pending', 'succeeded', 'failed');
CREATE TYPE "public"."tour_difficulty" AS ENUM ('easy', 'medium', 'difficult');
CREATE TYPE "public"."tour_status" AS ENUM ('coming_soon', 'draft', 'live');
CREATE TYPE "tour"."media_type" AS ENUM ('image', 'video');


-- #############################################################################
-- ### 2. TABLE CREATION
-- #############################################################################

-- TOUR SCHEMA
CREATE TABLE "tour"."partners" (
    "id" bigint NOT NULL,
    "name" text,
    "description" text,
    "contact_email" text,
    "website_url" text,
    "is_verified" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE "tour"."partners" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."partners_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "tour"."tours" (
    "id" bigint NOT NULL,
    "partner_id" bigint,
    "name" text,
    "slug" text,
    "duration_days" smallint,
    "max_group_size" smallint,
    "min_booking_size" smallint DEFAULT 1,
    "difficulty" public.tour_difficulty,
    "price" numeric,
    "currency" character(3) DEFAULT 'USD'::bpchar,
    "summary" text,
    "description" jsonb,
    "created_at" timestamp with time zone DEFAULT now(),
    "tour_coordinates" extensions.geography(Point,4326),
    "status" public.tour_status DEFAULT 'draft'::public.tour_status,
    "created_by" uuid,
    "updated_at" timestamp with time zone,
    "is_deleted" boolean DEFAULT false,
    "deleted_at" timestamp with time zone,
    "deleted_by" uuid
);
ALTER TABLE "tour"."tours" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."tours_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- ACCOUNT SCHEMA
CREATE TABLE "account"."profiles" (
    "id" uuid NOT NULL,
    "partner_id" bigint,
    "first_name" text,
    "last_name" text,
    "avatar_url" text,
    "role" public.app_role NOT NULL DEFAULT 'customer'::public.app_role,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone DEFAULT now()
);

-- GEOGRAPHY SCHEMA
CREATE TABLE "geography"."locations" (
    "id" bigint NOT NULL,
    "parent_id" bigint,
    "name" text,
    "level" public.location_level,
    "iso_code_alpha2" character(2),
    "geog" extensions.geography(Point,4326),
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE "geography"."locations" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "geography"."locations_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "geography"."timezones" (
    "id" bigint NOT NULL,
    "iana_name" text,
    "canonical_name" text,
    "display_name" text,
    "region" text,
    "country_codes" text[],
    "utc_offset_std" interval,
    "utc_offset_dst" interval,
    "abbreviation_std" text,
    "abbreviation_dst" text,
    "is_canonical" boolean DEFAULT true,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone
);
ALTER TABLE "geography"."timezones" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "geography"."timezones_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "geography"."location_timezones" (
    "id" bigint NOT NULL,
    "location_id" bigint NOT NULL,
    "timezone_id" bigint NOT NULL,
    "is_primary" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE "geography"."location_timezones" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "geography"."location_timezones_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- TOUR SCHEMA (CONTINUED)
CREATE TABLE "tour"."tour_schedules" (
    "id" bigint NOT NULL,
    "tour_id" bigint,
    "start_location_id" bigint,
    "start_date" timestamp with time zone,
    "seats_available" integer,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE "tour"."tour_schedules" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."tour_schedules_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "tour"."bookings" (
    "id" bigint NOT NULL,
    "tour_schedule_id" bigint,
    "customer_id" uuid,
    "seats_booked" integer,
    "price_paid" numeric,
    "currency_paid" character(3),
    "status" public.booking_status,
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT now(),
    "partner_id" bigint
);
ALTER TABLE "tour"."bookings" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."bookings_booking_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- BILLING SCHEMA
CREATE TABLE "billing"."payments" (
    "id" bigint NOT NULL,
    "booking_id" bigint,
    "amount" numeric,
    "currency" character(3),
    "provider" text,
    "stripe_session_id" text,
    "provider_payment_id" text,
    "status" public.payment_status DEFAULT 'pending'::public.payment_status,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE "billing"."payments" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "billing"."payments_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "billing"."stripe_webhook_events" (
    "event_id" text NOT NULL,
    "processed_at" timestamp with time zone DEFAULT now()
);

-- TOUR SCHEMA (CONTINUED)
CREATE TABLE "tour"."availability_exceptions" (
    "id" bigint NOT NULL,
    "tour_id" bigint,
    "unavailable_date" timestamp with time zone,
    "reason" text,
    "created_at" timestamp with time zone DEFAULT now(),
    "partner_id" bigint
);
ALTER TABLE "tour"."availability_exceptions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."availability_exceptions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "tour"."availability_rules" (
    "id" bigint NOT NULL,
    "tour_id" bigint,
    "start_date" timestamp with time zone,
    "end_date" timestamp with time zone,
    "days_of_week" integer,
    "created_at" timestamp with time zone DEFAULT now(),
    "partner_id" bigint
);

ALTER TABLE "tour"."availability_rules" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."availability_rules_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "tour"."reviews" (
    "id" bigint NOT NULL,
    "review_text" text,
    "rating" integer,
    "tour_id" bigint,
    "customer_id" uuid,
    "created_at" timestamp with time zone DEFAULT now(),
    CONSTRAINT "reviews_rating_check" CHECK (((rating >= 1) AND (rating <= 5)))
);
ALTER TABLE "tour"."reviews" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."reviews_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "tour"."tour_guides" (
    "tour_schedule_id" bigint NOT NULL,
    "guide_id" uuid NOT NULL
);

CREATE TABLE "tour"."tour_locations" (
    "tour_id" bigint NOT NULL,
    "location_id" bigint NOT NULL,
    "day_of_tour" integer,
    "description" text
);

CREATE TABLE "tour"."tour_media" (
    "id" bigint NOT NULL,
    "tour_id" bigint,
    "media_type" tour.media_type,
    "url" text,
    "filename" text,
    "alt_text" text,
    "caption" text,
    "display_order" integer,
    "is_cover" boolean DEFAULT false,
    "file_size" bigint,
    "dimensions" jsonb,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone
);
ALTER TABLE "tour"."tour_media" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "tour"."tour_media_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "tour"."wishlists" (
    "user_id" uuid NOT NULL,
    "tour_id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now()
);

-- #############################################################################
-- ### 3. FUNCTIONS
-- #############################################################################

CREATE OR REPLACE FUNCTION "public"."get_server_time"() RETURNS json
    LANGUAGE "plpgsql"
    SET search_path = ''
    AS $$
BEGIN
    RETURN json_build_object('server_time', TO_CHAR(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.US"Z"'));
END;
$$;

CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS trigger
    LANGUAGE "plpgsql"
    SET search_path = ''
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.user_has_role(required_roles public.app_role[])
 RETURNS boolean
 LANGUAGE sql
 STABLE
 SET search_path = ''
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM account.profiles
    WHERE id = auth.uid()
      AND role = ANY(required_roles)
  );
$function$
;

CREATE OR REPLACE FUNCTION "tour"."handle_expired_bookings"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET search_path = ''
    AS $$
BEGIN
    -- Update tour_schedules by adding back seats from expired bookings
    UPDATE tour.tour_schedules ts
    SET seats_available = ts.seats_available + b.seats_booked
    FROM tour.bookings b
    WHERE b.tour_schedule_id = ts.id
      AND b.status = 'pending'
      AND b.expires_at < NOW();

    -- Update the status of expired bookings
    UPDATE tour.bookings
    SET status = 'expired'
    WHERE status = 'pending'
      AND expires_at < NOW();
END;
$$;

CREATE OR REPLACE FUNCTION "tour"."update_booking_cancelled_and_release_seats"(booking_id_param bigint) RETURNS "void"
    LANGUAGE "plpgsql"
    SET search_path = ''
    AS $$
DECLARE
    schedule_id INT;
    seats_to_release INT;
BEGIN
    -- Find the booking and get schedule_id and seats_booked
    SELECT tour_schedule_id, seats_booked INTO schedule_id, seats_to_release
    FROM tour.bookings
    WHERE id = booking_id_param::bigint;

    -- If booking found, update its status to 'cancelled'
    IF FOUND THEN
        UPDATE tour.bookings
        SET status = 'cancelled'
        WHERE id = booking_id_param::bigint;

        -- Release the seats back to tour_schedules
        UPDATE tour.tour_schedules
        SET seats_available = seats_available + seats_to_release
        WHERE id = schedule_id;
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION "tour"."update_booking_expired_and_release_seats"(booking_id_param text) RETURNS "void"
    LANGUAGE "plpgsql"
    SET search_path = ''
    AS $$
DECLARE
    schedule_id INT;
    seats_to_release INT;
BEGIN
    -- Find the booking and get schedule_id and seats_booked
    SELECT tour_schedule_id, seats_booked INTO schedule_id, seats_to_release
    FROM tour.bookings
    WHERE id = booking_id_param::bigint;

    -- If booking found, update its status to 'expired'
    IF FOUND THEN
        UPDATE tour.bookings
        SET status = 'expired'
        WHERE id = booking_id_param::bigint;

        -- Release the seats back to tour_schedules
        UPDATE tour.tour_schedules
        SET seats_available = seats_available + seats_to_release
        WHERE id = schedule_id;
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION "tour"."update_tours_updated_at"() RETURNS trigger
    LANGUAGE "plpgsql"
    SET search_path = ''
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


-- #############################################################################
-- ### 4. VIEWS
-- #############################################################################

CREATE OR REPLACE VIEW "internal_api"."tours"
WITH (security_invoker = on) AS
 SELECT id,
    partner_id,
    name,
    slug,
    duration_days,
    max_group_size,
    min_booking_size,
    difficulty,
    price,
    currency,
    summary,
    description,
    created_at,
    tour_coordinates,
    status,
    created_by,
    updated_at,
    is_deleted,
    deleted_at,
    deleted_by
   FROM tour.tours
  WHERE (is_deleted = false);

  -- A primary key is required for an entity to be reflected in the GraphQL schema (https://supabase.com/docs/guides/graphql/views)
  COMMENT ON VIEW "internal_api"."tours"
  IS $$@graphql({
    "field_name": "internalTours",
    "name": "InternalTours",
    "primary_key_columns": ["id"]
  })$$;

  CREATE OR REPLACE VIEW "internal_api"."tour_media"
  WITH (security_invoker = on) AS
    SELECT id,
      tour_id,
      media_type,
      url,
      filename,
      alt_text,
      caption,
      display_order,
      is_cover,
      file_size,
      dimensions,
      created_at,
      updated_at
    FROM tour.tour_media;

    -- A primary key is required for an entity to be reflected in the GraphQL schema (https://supabase.com/docs/guides/graphql/views)
    COMMENT ON VIEW "internal_api"."tour_media"
    IS $$@graphql({
      "field_name": "internalTourMedia",
      "name": "InternalTourMedia",
      "primary_key_columns": ["id"]
    })$$;

    CREATE OR REPLACE VIEW "internal_api"."tour_availability_rules"
    WITH
      (security_invoker = on) AS
    SELECT
      id,
      tour_id,
      start_date,
      end_date,
      days_of_week,
      created_at,
      partner_id
    FROM
      tour.availability_rules;

    -- A primary key is required for an entity to be reflected in the GraphQL schema (https://supabase.com/docs/guides/graphql/views)
    COMMENT ON VIEW "internal_api"."tour_availability_rules"
    IS $$@graphql({
      "field_name": "internalTourAvailabilityRules",
      "name": "InternalTourAvailabilityRules",
      "primary_key_columns": ["id"]
    })$$;

    CREATE OR REPLACE VIEW "internal_api"."tour_availability_exceptions"
    WITH
      (security_invoker = on) AS
    SELECT
      id,
      tour_id,
      unavailable_date,
      reason,
      created_at,
      partner_id
    FROM
      tour.availability_exceptions;

    -- A primary key is required for an entity to be reflected in the GraphQL schema (https://supabase.com/docs/guides/graphql/views)
    COMMENT ON VIEW "internal_api"."tour_availability_exceptions"
    IS $$@graphql({
      "field_name": "internalTourAvailabilityExceptions",
      "name": "InternalTourAvailabilityExceptions",
      "primary_key_columns": ["id"]
    })$$;

    CREATE OR REPLACE VIEW "internal_api"."tour_partners"
    WITH
      (security_invoker = on) AS
    SELECT
      id,
      name AS brand_name,
      description,
      contact_email AS email,
      website_url AS website,
      is_verified,
      created_at
    FROM
      tour.partners;

    -- A primary key is required for an entity to be reflected in the GraphQL schema (https://supabase.com/docs/guides/graphql/views)
    COMMENT ON VIEW "internal_api"."tour_partners"
    IS $$@graphql({
      "field_name": "internalTourPartners",
      "name": "InternalTourPartners",
      "primary_key_columns": ["id"]
    })$$;

  CREATE OR REPLACE VIEW "public"."tours" AS
   SELECT t.id,
      t.name,
      t.slug,
      COALESCE(avg_rating.avg_rating, (0)::numeric) AS avg_rating,
      cover_media.url AS cover_image_url,
      ( SELECT json_agg(json_build_object('url', tm.url, 'alt_text', tm.alt_text)) AS json_agg
             FROM tour.tour_media tm
            WHERE ((tm.tour_id = t.id) AND (tm.is_cover = false))) AS gallery_images,
      t.duration_days,
      t.max_group_size AS participants,
      t.price,
      t.currency,
      t.difficulty,
      t.status,
      t.created_at AS published_at,
      st_x((t.tour_coordinates)::extensions.geometry) AS longitude,
      st_y((t.tour_coordinates)::extensions.geometry) AS latitude,
      p.name AS provider_name,
      p.website_url AS provider_website,
      ( SELECT json_agg(json_build_object('day', tl.day_of_tour, 'location_name', l.name, 'description', tl.description)) AS json_agg
             FROM (tour.tour_locations tl
               JOIN geography.locations l ON ((tl.location_id = l.id)))
            WHERE (tl.tour_id = t.id)) AS locations
     FROM (((tour.tours t
       LEFT JOIN tour.partners p ON ((t.partner_id = p.id)))
       LEFT JOIN ( SELECT tour.reviews.tour_id,
              avg(tour.reviews.rating) AS avg_rating
             FROM tour.reviews
            GROUP BY tour.reviews.tour_id) avg_rating ON ((t.id = avg_rating.tour_id)))
       LEFT JOIN ( SELECT tour.tour_media.tour_id,
              tour.tour_media.url
             FROM tour.tour_media
            WHERE (tour.tour_media.is_cover = true)) cover_media ON ((t.id = cover_media.tour_id)))
    WHERE (t.is_deleted = false);

    -- A primary key is required for an entity to be reflected in the GraphQL schema (https://supabase.com/docs/guides/graphql/views)
    COMMENT ON VIEW "public"."tours"
    IS $$@graphql({
      "field_name": "tours",
      "name": "Tours",
      "primary_key_columns": ["id"]
    })$$;

-- #############################################################################
-- ### 5. PRIMARY KEYS & CONSTRAINTS
-- #############################################################################

ALTER TABLE ONLY "account"."profiles" ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "billing"."payments" ADD CONSTRAINT "payments_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "billing"."stripe_webhook_events" ADD CONSTRAINT "stripe_webhook_events_pkey" PRIMARY KEY ("event_id");
ALTER TABLE ONLY "geography"."location_timezones" ADD CONSTRAINT "location_timezones_location_id_timezone_id_key" UNIQUE ("location_id", "timezone_id");
ALTER TABLE ONLY "geography"."location_timezones" ADD CONSTRAINT "location_timezones_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "geography"."locations" ADD CONSTRAINT "locations_parent_id_name_key" UNIQUE ("parent_id", "name");
ALTER TABLE ONLY "geography"."locations" ADD CONSTRAINT "locations_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "geography"."timezones" ADD CONSTRAINT "timezones_iana_name_key" UNIQUE ("iana_name");
ALTER TABLE ONLY "geography"."timezones" ADD CONSTRAINT "timezones_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."availability_exceptions" ADD CONSTRAINT "availability_exceptions_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."availability_exceptions" ADD CONSTRAINT "availability_exceptions_tour_id_unavailable_date_key" UNIQUE ("tour_id", "unavailable_date");
ALTER TABLE ONLY "tour"."availability_rules" ADD CONSTRAINT "availability_rules_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."bookings" ADD CONSTRAINT "bookings_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."partners" ADD CONSTRAINT "partners_contact_email_key" UNIQUE ("contact_email");
ALTER TABLE ONLY "tour"."partners" ADD CONSTRAINT "partners_name_key" UNIQUE ("name");
ALTER TABLE ONLY "tour"."partners" ADD CONSTRAINT "partners_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."reviews" ADD CONSTRAINT "reviews_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."reviews" ADD CONSTRAINT "reviews_tour_id_customer_id_key" UNIQUE ("tour_id", "customer_id");
ALTER TABLE ONLY "tour"."tour_guides" ADD CONSTRAINT "tour_guides_pkey" PRIMARY KEY ("tour_schedule_id", "guide_id");
ALTER TABLE ONLY "tour"."tour_locations" ADD CONSTRAINT "tour_locations_pkey" PRIMARY KEY ("tour_id", "location_id");
ALTER TABLE ONLY "tour"."tour_media" ADD CONSTRAINT "tour_media_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."tour_schedules" ADD CONSTRAINT "tour_schedules_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."tour_schedules" ADD CONSTRAINT "tour_schedules_tour_id_start_date_key" UNIQUE ("tour_id", "start_date");
ALTER TABLE ONLY "tour"."tours" ADD CONSTRAINT "tours_pkey1" PRIMARY KEY ("id");
ALTER TABLE ONLY "tour"."tours" ADD CONSTRAINT "tours_slug_key1" UNIQUE ("slug");
ALTER TABLE ONLY "tour"."wishlists" ADD CONSTRAINT "wishlists_pkey" PRIMARY KEY ("user_id", "tour_id");


-- #############################################################################
-- ### 6. INDEXES
-- #############################################################################

CREATE INDEX "availability_exceptions_partner_id_idx" ON "tour"."availability_exceptions" USING "btree" ("partner_id");
CREATE INDEX "availability_exceptions_tour_id_idx" ON "tour"."availability_exceptions" USING "btree" ("tour_id");
CREATE INDEX "availability_rules_partner_id_idx" ON "tour"."availability_rules" USING "btree" ("partner_id");
CREATE INDEX "availability_rules_tour_id_idx" ON "tour"."availability_rules" USING "btree" ("tour_id");
CREATE INDEX "bookings_customer_id_idx" ON "tour"."bookings" USING "btree" ("customer_id");
CREATE INDEX "bookings_partner_id_idx" ON "tour"."bookings" USING "btree" ("partner_id");
CREATE INDEX "bookings_tour_schedule_id_idx" ON "tour"."bookings" USING "btree" ("tour_schedule_id");
CREATE INDEX "idx_location_timezones_is_primary" ON "geography"."location_timezones" USING "btree" ("is_primary");
CREATE INDEX "idx_location_timezones_location_id" ON "geography"."location_timezones" USING "btree" ("location_id");
CREATE INDEX "idx_location_timezones_timezone_id" ON "geography"."location_timezones" USING "btree" ("timezone_id");
CREATE INDEX "idx_locations_geog" ON "geography"."locations" USING "gist" ("geog");
CREATE INDEX "idx_timezones_canonical_name" ON "geography"."timezones" USING "btree" ("canonical_name");
CREATE INDEX "idx_timezones_country_codes" ON "geography"."timezones" USING "gin" ("country_codes");
CREATE INDEX "idx_timezones_iana_name" ON "geography"."timezones" USING "btree" ("iana_name");
CREATE INDEX "idx_timezones_is_canonical" ON "geography"."timezones" USING "btree" ("is_canonical");
CREATE INDEX "idx_timezones_region" ON "geography"."timezones" USING "btree" ("region");
CREATE INDEX "locations_parent_id_idx" ON "geography"."locations" USING "btree" ("parent_id");
CREATE INDEX "profiles_partner_id_idx" ON "account"."profiles" USING "btree" ("partner_id");
CREATE INDEX "reviews_customer_id_idx" ON "tour"."reviews" USING "btree" ("customer_id");
CREATE INDEX "reviews_tour_id_idx" ON "tour"."reviews" USING "btree" ("tour_id");
CREATE UNIQUE INDEX "tour_media_unique_cover_idx" ON "tour"."tour_media" USING btree (tour_id) WHERE (is_cover = true);
CREATE INDEX "tour_media_tour_id_idx" ON "tour"."tour_media" USING "btree" ("tour_id");
CREATE INDEX "tour_media_tour_id_order_idx" ON "tour"."tour_media" USING "btree" ("tour_id", "display_order");
CREATE INDEX "tour_schedules_tour_id_idx" ON "tour"."tour_schedules" USING "btree" ("tour_id");
CREATE INDEX "tours_created_by_idx" ON "tour"."tours" USING "btree" ("created_by");
CREATE INDEX "tours_is_deleted_idx" ON "tour"."tours" USING "btree" ("is_deleted");
CREATE INDEX "tours_partner_id_idx" ON "tour"."tours" USING "btree" ("partner_id");


-- #############################################################################
-- ### 7. FOREIGN KEYS
-- #############################################################################

ALTER TABLE ONLY "account"."profiles" ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;
ALTER TABLE ONLY "account"."profiles" ADD CONSTRAINT "profiles_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "tour"."partners"("id") ON DELETE SET NULL;
ALTER TABLE ONLY "billing"."payments" ADD CONSTRAINT "payments_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "tour"."bookings"("id");
ALTER TABLE ONLY "geography"."location_timezones" ADD CONSTRAINT "location_timezones_location_id_fkey" FOREIGN KEY ("location_id") REFERENCES "geography"."locations"("id") ON DELETE CASCADE;
ALTER TABLE ONLY "geography"."location_timezones" ADD CONSTRAINT "location_timezones_timezone_id_fkey" FOREIGN KEY ("timezone_id") REFERENCES "geography"."timezones"("id") ON DELETE CASCADE;
ALTER TABLE ONLY "geography"."locations" ADD CONSTRAINT "locations_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "geography"."locations"("id");
ALTER TABLE ONLY "tour"."availability_exceptions" ADD CONSTRAINT "availability_exceptions_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "tour"."partners"("id");
ALTER TABLE ONLY "tour"."availability_exceptions" ADD CONSTRAINT "availability_exceptions_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."availability_rules" ADD CONSTRAINT "availability_rules_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "tour"."partners"("id");
ALTER TABLE ONLY "tour"."availability_rules" ADD CONSTRAINT "availability_rules_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."bookings" ADD CONSTRAINT "bookings_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "auth"."users"("id");
ALTER TABLE ONLY "tour"."bookings" ADD CONSTRAINT "bookings_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "tour"."partners"("id");
ALTER TABLE ONLY "tour"."bookings" ADD CONSTRAINT "bookings_tour_schedule_id_fkey" FOREIGN KEY ("tour_schedule_id") REFERENCES "tour"."tour_schedules"("id");
ALTER TABLE ONLY "tour"."reviews" ADD CONSTRAINT "reviews_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "auth"."users"("id");
ALTER TABLE ONLY "tour"."reviews" ADD CONSTRAINT "reviews_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."tour_guides" ADD CONSTRAINT "tour_guides_guide_id_fkey" FOREIGN KEY ("guide_id") REFERENCES "auth"."users"("id");
ALTER TABLE ONLY "tour"."tour_guides" ADD CONSTRAINT "tour_guides_tour_schedule_id_fkey" FOREIGN KEY ("tour_schedule_id") REFERENCES "tour"."tour_schedules"("id");
ALTER TABLE ONLY "tour"."tour_locations" ADD CONSTRAINT "tour_locations_location_id_fkey" FOREIGN KEY ("location_id") REFERENCES "geography"."locations"("id");
ALTER TABLE ONLY "tour"."tour_locations" ADD CONSTRAINT "tour_locations_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."tour_media" ADD CONSTRAINT "tour_media_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."tour_schedules" ADD CONSTRAINT "tour_schedules_start_location_id_fkey" FOREIGN KEY ("start_location_id") REFERENCES "geography"."locations"("id");
ALTER TABLE ONLY "tour"."tour_schedules" ADD CONSTRAINT "tour_schedules_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."tours" ADD CONSTRAINT "tours_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");
ALTER TABLE ONLY "tour"."tours" ADD CONSTRAINT "tours_deleted_by_fkey" FOREIGN KEY ("deleted_by") REFERENCES "auth"."users"("id");
ALTER TABLE ONLY "tour"."tours" ADD CONSTRAINT "tours_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "tour"."partners"("id");
ALTER TABLE ONLY "tour"."wishlists" ADD CONSTRAINT "wishlists_tour_id_fkey" FOREIGN KEY ("tour_id") REFERENCES "tour"."tours"("id");
ALTER TABLE ONLY "tour"."wishlists" ADD CONSTRAINT "wishlists_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");


-- #############################################################################
-- ### 8. TRIGGERS
-- #############################################################################

CREATE OR REPLACE FUNCTION "account"."handle_new_user"() RETURNS trigger
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET search_path = ''
    AS $$
BEGIN
  INSERT INTO account.profiles (id, first_name, last_name, role)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'first_name',
    new.raw_user_meta_data->>'last_name',
    'customer'::public.app_role -- Assign the default role of 'customer'.
  );
  RETURN new;
END;
$$;

-- Returns true if the currently-authenticated user’s own row in account.profiles has role = 'admin'
CREATE OR REPLACE FUNCTION public.caller_is_admin()
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT (SELECT role = 'admin'
          FROM account.profiles
          WHERE id = auth.uid());
$$;

create or replace function account.check_admin_only_cols()
returns trigger
language plpgsql
SET search_path = ''
as $$
declare
  caller_role public.app_role;
begin
  -- Who is doing this?
  select role into caller_role
  from account.profiles
  where id = auth.uid();

  if caller_role <> 'admin' then
    raise exception 'only admin can modify partner_id or is_active';
  end if;

  return new;
end;
$$;

create or replace function account.check_role_update()
returns trigger
language plpgsql
SET search_path = ''
as $$
declare
  caller_role public.app_role;
begin
  -- If role is not being changed, do nothing
  if new.role is not distinct from old.role then
    return new;
  end if;

  -- Who is doing this?
  select role into caller_role
  from account.profiles
  where id = auth.uid();

  case caller_role
    when 'admin' then
      if new.role = 'admin' then
        raise exception 'admin role may not be assigned';
      end if;
    when 'partner_admin' then
      if new.role not in ('guide','lead_guide') then
        raise exception 'partner_admin may only assign guide or lead_guide';
      end if;
    else
      raise exception 'insufficient privilege to change role';
  end case;

  return new;
end;
$$;

CREATE TRIGGER "on_auth_user_created" AFTER INSERT ON "auth"."users" FOR EACH ROW EXECUTE FUNCTION "account"."handle_new_user"();
CREATE TRIGGER "tours_updated_at_trigger" BEFORE UPDATE ON "tour"."tours" FOR EACH ROW EXECUTE FUNCTION "tour"."update_tours_updated_at"();
CREATE TRIGGER "update_timezones_updated_at" BEFORE UPDATE ON "geography"."timezones" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

create trigger trg_check_admin_only_cols
before update of partner_id, is_active on account.profiles
for each row
execute function account.check_admin_only_cols();

create trigger trg_check_role_update
before update of role on account.profiles
for each row
execute function account.check_role_update();

-- #############################################################################
-- ### 9. ROW LEVEL SECURITY (RLS) & POLICIES
-- #############################################################################

-- Enable RLS
ALTER TABLE "account"."profiles" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "billing"."payments" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "billing"."stripe_webhook_events" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "geography"."location_timezones" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "geography"."locations" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "geography"."timezones" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."availability_exceptions" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."availability_rules" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."bookings" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."partners" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."reviews" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."tour_guides" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."tour_locations" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."tour_media" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."tour_schedules" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."tours" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "tour"."wishlists" ENABLE ROW LEVEL SECURITY;

-- Row insertion and deletion are prohibited due each rows are generated automatically by on_auth_user_created trigger that execute handle_new_user()
CREATE POLICY "deny_delete_profiles" ON "account"."profiles" FOR DELETE TO "authenticated" USING (false);
CREATE POLICY "deny_insert_profiles" ON "account"."profiles" FOR INSERT TO "authenticated" WITH CHECK (false);

-- SELECT
CREATE POLICY "profiles_select_all_if_admin"
ON account.profiles
FOR SELECT
TO authenticated
USING (public.caller_is_admin() OR id = auth.uid());

-- UPDATE
CREATE POLICY "profiles_update_owner"
ON account.profiles
FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

CREATE POLICY "profiles_update_admin"
ON account.profiles
FOR UPDATE
TO authenticated
USING (public.caller_is_admin());

CREATE POLICY "availability_exceptions_delete_policy" ON "tour"."availability_exceptions" FOR DELETE TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_exceptions.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_exceptions_insert_policy" ON "tour"."availability_exceptions" FOR INSERT TO "authenticated" WITH CHECK (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_exceptions.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_exceptions_read_policy" ON "tour"."availability_exceptions" FOR SELECT TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_exceptions.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_exceptions_update_policy" ON "tour"."availability_exceptions" FOR UPDATE TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_exceptions.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))))) WITH CHECK (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_exceptions.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_rules_delete_policy" ON "tour"."availability_rules" FOR DELETE TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_rules.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_rules_insert_policy" ON "tour"."availability_rules" FOR INSERT TO "authenticated" WITH CHECK (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_rules.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_rules_read_policy" ON "tour"."availability_rules" FOR SELECT TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_rules.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "availability_rules_update_policy" ON "tour"."availability_rules" FOR UPDATE TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_rules.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))))) WITH CHECK (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = availability_rules.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "bookings_delete_policy" ON "tour"."bookings" FOR DELETE TO "authenticated" USING (false);
CREATE POLICY "bookings_insert_policy" ON "tour"."bookings" FOR INSERT TO "authenticated" WITH CHECK (false);
CREATE POLICY "bookings_read_policy" ON "tour"."bookings" FOR SELECT TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = bookings.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "bookings_update_policy" ON "tour"."bookings" FOR UPDATE TO "authenticated" USING (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = bookings.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))))) WITH CHECK (((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.partner_id = bookings.partner_id) AND (p.role = 'partner_admin'::public.app_role)))) OR (EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))));
CREATE POLICY "partners_delete_policy" ON "tour"."partners" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))));
CREATE POLICY "partners_insert_policy" ON "tour"."partners" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))));
CREATE POLICY "partners_read_policy" ON "tour"."partners" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))));
CREATE POLICY "partners_update_policy" ON "tour"."partners" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM account.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'admin'::public.app_role)))));
CREATE POLICY "deny_delete_reviews" ON "tour"."reviews" FOR DELETE TO "authenticated" USING (false);
CREATE POLICY "deny_insert_reviews" ON "tour"."reviews" FOR INSERT TO "authenticated" WITH CHECK (false);
CREATE POLICY "deny_update_reviews" ON "tour"."reviews" FOR UPDATE TO "authenticated" USING (false) WITH CHECK (false);
CREATE POLICY "reviews_select_partner_level" ON "tour"."reviews" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM (account.profiles p
     JOIN tour.tours t ON ((p.partner_id = t.partner_id)))
  WHERE ((p.id = auth.uid()) AND (t.id = reviews.tour_id)))));
CREATE POLICY "tour_guides_delete_role_and_partner" ON "tour"."tour_guides" FOR DELETE TO "authenticated" USING ((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM (tour.tour_schedules ts
     JOIN tour.tours t ON ((ts.tour_id = t.id)))
  WHERE ((ts.id = tour_guides.tour_schedule_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid()))))))));
CREATE POLICY "tour_guides_insert_role_and_partner" ON "tour"."tour_guides" FOR INSERT TO "authenticated" WITH CHECK ((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM (tour.tour_schedules ts
     JOIN tour.tours t ON ((ts.tour_id = t.id)))
  WHERE ((ts.id = tour_guides.tour_schedule_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid()))))))));
CREATE POLICY "tour_guides_select_partner_isolation" ON "tour"."tour_guides" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM (tour.tour_schedules ts
     JOIN tour.tours t ON ((ts.tour_id = t.id)))
  WHERE ((ts.id = tour_guides.tour_schedule_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))));
CREATE POLICY "tour_guides_update_role_and_partner" ON "tour"."tour_guides" FOR UPDATE TO "authenticated" USING ((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM (tour.tour_schedules ts
     JOIN tour.tours t ON ((ts.tour_id = t.id)))
  WHERE ((ts.id = tour_guides.tour_schedule_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))) WITH CHECK ((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM (tour.tour_schedules ts
     JOIN tour.tours t ON ((ts.tour_id = t.id)))
  WHERE ((ts.id = tour_guides.tour_schedule_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid()))))))));
CREATE POLICY "tour_locations_delete_by_roles" ON "tour"."tour_locations" FOR DELETE TO "authenticated" USING (((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_locations.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "tour_locations_insert_by_roles" ON "tour"."tour_locations" FOR INSERT TO "authenticated" WITH CHECK (((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_locations.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "tour_locations_select_clean" ON "tour"."tour_locations" FOR SELECT TO "authenticated" USING (true);
CREATE POLICY "tour_locations_update_by_roles" ON "tour"."tour_locations" FOR UPDATE TO "authenticated" USING (((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_locations.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid()))))))))) WITH CHECK (((public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_locations.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "tour_media_delete_with_admin_bypass" ON "tour"."tour_media" FOR DELETE TO "authenticated" USING (((public.user_has_role(ARRAY['admin'::public.app_role]) OR (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_media.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "tour_media_insert_with_admin_bypass" ON "tour"."tour_media" FOR INSERT TO "authenticated" WITH CHECK (((public.user_has_role(ARRAY['admin'::public.app_role]) OR (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_media.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "tour_media_select_with_admin_bypass" ON "tour"."tour_media" FOR SELECT TO "authenticated" USING (((public.user_has_role(ARRAY['admin'::public.app_role]) OR (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_media.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "tour_media_update_with_admin_bypass" ON "tour"."tour_media" FOR UPDATE TO "authenticated" USING (((public.user_has_role(ARRAY['admin'::public.app_role]) OR (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_media.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid()))))))))) WITH CHECK (((public.user_has_role(ARRAY['admin'::public.app_role]) OR (EXISTS ( SELECT 1
   FROM tour.tours t
  WHERE ((t.id = tour_media.tour_id) AND (t.partner_id = ( SELECT profiles.partner_id
           FROM account.profiles
          WHERE (profiles.id = auth.uid())))))))));
CREATE POLICY "deny_delete_tour_schedules" ON "tour"."tour_schedules" FOR DELETE TO "authenticated" USING (false);
CREATE POLICY "deny_insert_tour_schedules" ON "tour"."tour_schedules" FOR INSERT TO "authenticated" WITH CHECK (false);
CREATE POLICY "deny_update_tour_schedules" ON "tour"."tour_schedules" FOR UPDATE TO "authenticated" USING (false) WITH CHECK (false);
CREATE POLICY "select_tour_schedules_partner_level" ON "tour"."tour_schedules" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM (account.profiles p
     JOIN tour.tours t ON ((p.partner_id = t.partner_id)))
  WHERE ((p.id = auth.uid()) AND (t.id = tour_schedules.tour_id)))));
CREATE POLICY "Admin can manage all tours" ON "tour"."tours" FOR ALL TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::public.app_role))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::public.app_role)))));
CREATE POLICY "Allow public read access on published tours" ON "tour"."tours" FOR SELECT TO "anon" USING ((status = 'live'::public.tour_status));
CREATE POLICY "Partner admin can create tours" ON "tour"."tours" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'partner_admin'::public.app_role) AND (profiles.partner_id = tours.partner_id)))));
CREATE POLICY "Partner admin can delete own tours" ON "tour"."tours" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'partner_admin'::public.app_role) AND (profiles.partner_id = tours.partner_id)))));
CREATE POLICY "Partner admin can read own tours" ON "tour"."tours" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND public.user_has_role(ARRAY['partner_admin'::public.app_role, 'admin'::public.app_role, 'guide'::public.app_role]) AND (profiles.partner_id = tours.partner_id)))));
CREATE POLICY "Partner admin can update own tours" ON "tour"."tours" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'partner_admin'::public.app_role) AND (profiles.partner_id = tours.partner_id))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM account.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'partner_admin'::public.app_role) AND (profiles.partner_id = tours.partner_id)))));
CREATE POLICY "deny_delete_wishlists" ON "tour"."wishlists" FOR DELETE TO "authenticated" USING (false);
CREATE POLICY "deny_insert_wishlists" ON "tour"."wishlists" FOR INSERT TO "authenticated" WITH CHECK (false);
CREATE POLICY "deny_select_wishlists" ON "tour"."wishlists" FOR SELECT TO "authenticated" USING (false);
CREATE POLICY "deny_update_wishlists" ON "tour"."wishlists" FOR UPDATE TO "authenticated" USING (false) WITH CHECK (false);


-- #############################################################################
-- ### 10. GRANTS
-- #############################################################################

GRANT ALL ON TABLE "account"."profiles" TO "anon";
GRANT ALL ON TABLE "account"."profiles" TO "authenticated";
GRANT ALL ON TABLE "account"."profiles" TO "service_role";
GRANT ALL ON TABLE "billing"."payments" TO "authenticated";
GRANT ALL ON TABLE "billing"."payments" TO "service_role";
GRANT ALL ON TABLE "billing"."stripe_webhook_events" TO "authenticated";
GRANT ALL ON TABLE "billing"."stripe_webhook_events" TO "service_role";
GRANT ALL ON TABLE "geography"."location_timezones" TO "authenticated";
GRANT ALL ON TABLE "geography"."location_timezones" TO "service_role";
GRANT ALL ON TABLE "geography"."locations" TO "authenticated";
GRANT ALL ON TABLE "geography"."locations" TO "service_role";
GRANT ALL ON TABLE "geography"."timezones" TO "authenticated";
GRANT ALL ON TABLE "geography"."timezones" TO "service_role";
GRANT ALL ON TABLE "tour"."availability_exceptions" TO "authenticated";
GRANT ALL ON TABLE "tour"."availability_exceptions" TO "service_role";
GRANT ALL ON TABLE "tour"."availability_rules" TO "authenticated";
GRANT ALL ON TABLE "tour"."availability_rules" TO "service_role";
GRANT ALL ON TABLE "tour"."bookings" TO "authenticated";
GRANT ALL ON TABLE "tour"."bookings" TO "service_role";
GRANT ALL ON TABLE "tour"."partners" TO "authenticated";
GRANT ALL ON TABLE "tour"."partners" TO "service_role";
GRANT ALL ON TABLE "tour"."reviews" TO "authenticated";
GRANT ALL ON TABLE "tour"."reviews" TO "service_role";
GRANT ALL ON TABLE "tour"."tour_guides" TO "authenticated";
GRANT ALL ON TABLE "tour"."tour_guides" TO "service_role";
GRANT ALL ON TABLE "tour"."tour_locations" TO "authenticated";
GRANT ALL ON TABLE "tour"."tour_locations" TO "service_role";
GRANT ALL ON TABLE "tour"."tour_media" TO "authenticated";
GRANT ALL ON TABLE "tour"."tour_media" TO "service_role";
GRANT ALL ON TABLE "tour"."tour_schedules" TO "authenticated";
GRANT ALL ON TABLE "tour"."tour_schedules" TO "service_role";
GRANT ALL ON TABLE "tour"."tours" TO "authenticated";
GRANT ALL ON TABLE "tour"."tours" TO "service_role";
GRANT ALL ON TABLE "tour"."wishlists" TO "authenticated";
GRANT ALL ON TABLE "tour"."wishlists" TO "service_role";

GRANT USAGE ON SCHEMA account TO authenticated;
GRANT USAGE ON SCHEMA billing TO authenticated;
GRANT USAGE ON SCHEMA geography TO authenticated;
GRANT USAGE ON SCHEMA tour TO authenticated;
